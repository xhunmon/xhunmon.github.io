{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"http://qincji.gitee.io","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2020-12-07T23:59:33.704Z","updated":"2020-12-04T01:58:30.392Z","comments":false,"path":"/404.html","permalink":"http://qincji.gitee.io/404.html","excerpt":"","text":""},{"title":"标签","date":"2020-12-07T23:59:33.703Z","updated":"2020-12-04T01:58:30.394Z","comments":false,"path":"tags/index.html","permalink":"http://qincji.gitee.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-12-07T23:59:33.648Z","updated":"2020-12-04T01:58:30.393Z","comments":false,"path":"repository/index.html","permalink":"http://qincji.gitee.io/repository/index.html","excerpt":"","text":""},{"title":"交个朋友呗~","date":"2020-12-08T09:54:18.797Z","updated":"2020-12-08T09:54:18.797Z","comments":true,"path":"links/index.html","permalink":"http://qincji.gitee.io/links/index.html","excerpt":"","text":""},{"title":"","date":"2020-12-08T09:31:40.699Z","updated":"2020-12-08T09:31:40.699Z","comments":false,"path":"life/index.html","permalink":"http://qincji.gitee.io/life/index.html","excerpt":"","text":"只言片语导航 &nbsp;- 不懂就搜，一搜就懂 var _hmt = _hmt || []; (function() { var hm = document.createElement(\"script\"); hm.src = \"https://hm.baidu.com/hm.js?786a6208323fbecfb41d71bfda8daca6\"; var s = document.getElementsByTagName(\"script\")[0]; s.parentNode.insertBefore(hm, s); })(); 只言片语，可寻万物 x 谷歌 百度 必应 360搜索 搜狗 网盘搜索 史级珍藏 大力盘搜索 今日热榜 虫部落 阿虚同学 地图搜租房 SoBooks Chrome插件 阿里矢量图 爱给网 娱乐 vip视频解析 阳光电影 电影FM 小霸王 看片狂人 蛋蛋赞影院 果汁排行榜 动漫之家 蓝光网 献给祖国的花朵 twinkl教学资源 全历史 古诗文 国学大师 金榜题名 电子报刊 名人名言 对对联 MBA智库 效率之王 手机破解软件 Kindle工具 教育工具总结 精品Mac应用 威风-果粉 谷歌镜像 在线刷流量 电子书共享 在线pdf转换 程序员幸福之星 程序员工具箱 谷歌开发者 在线工具库 开源中国 私活平台汇总 前端工具 LeetCode算法 安卓开源汇总 程序员导航 有趣的偏门知识 探月工程数据 动物图鉴 医学信息 中国色 中国哲学书 养蜜蜂 中国生物名录 中国古今妖怪 云游中国"},{"title":"关于","date":"2020-12-07T23:59:33.679Z","updated":"2020-12-04T09:23:52.116Z","comments":false,"path":"about/index.html","permalink":"http://qincji.gitee.io/about/index.html","excerpt":"","text":"毕业至今已有4载有余，一直耕耘于Android以及NDK领域。而起于兴趣向往音视频领域发展，也已有一年有多。音视频领域犹如瀚海宇宙，我怒向翱翔之中。 &#123; name: '秦城季' age: 29, gender: '男', profession: 'Android &amp; 音视频', experience: '4年+', address: '广东省广州市', education: '本科', github: 'https://github.com/xhunmon', blog: 'https://xhunmon.github.io', csdn: 'https://blog.csdn.net/github_38117599' email: 'xhunmon@126.com', description: '致力于Android与音视频领域', skills: [ ['Java', 'Dart', 'Jni','C++', 'Shell'], ['Git', 'SVN'], ['音视频'] ] &#125; 用代码谱写的青春绽放出了炫丽的新时代 ——向每一个位码农致敬~ ​"},{"title":"","date":"2020-12-07T23:59:33.697Z","updated":"2020-07-19T12:19:50.000Z","comments":true,"path":"life/static/js/keyword.js","permalink":"http://qincji.gitee.io/life/static/js/keyword.js","excerpt":"","text":"$(function () { // 默认搜索引擎记录 var searchTypeStore = { set: function (type) { localStorage.setItem('SearchType', type); }, get: function () { return localStorage.getItem('SearchType') || 'baidu'; }, }; var $searchMethods = $('#search_methods'); var $searchLogo = $('#search_logo'); var initSearchType = searchTypeStore.get(); $searchLogo.addClass(initSearchType).data('type', initSearchType); var search_types = [ { url: 'https://www.baidu.com/s?wd=', type: 'baidu' }, { url: 'https://www.sogou.com/web?query=', type: 'sogou' }, { url: 'https://cn.bing.com/search?q=', type: 'bing' }, { url: 'https://www.so.com/s?q=', type: 'so' }, { url: 'https://www.google.com/search?q=', type: 'google' }, { url: 'http://www.cilimao.cc/search?word=', type: 'cili' }, { url: 'http://neets.cc/search?key=', type: 'yingyin' }, { url: 'http://www.panduoduo.net/s/name/', type: 'wangpan' }, ]; $searchLogo.on('click', function () { $searchMethods.show(); }); // 搜索引擎切换 $searchMethods.on('click', 'li', function () { var type = $(this).data('type'); searchTypeStore.set(type); $searchLogo.removeClass() .data('type', type) .addClass(type + ' search-logo'); $searchMethods.hide(); $('#search_keyword').focus(); }); $searchMethods.on('mouseleave', function () { $searchMethods.hide(); }); var EVENT_CLEAR_KEYWORD = 'clearKeyword'; var EVENT_SEARCH = 'search'; // 关键词搜索输入 $('#search_keyword').on('keyup', function (event) { var keyword = $(this).val(); if(event.which==13){ if($('#search_result .active').length>0){ keyword = $('#search_result .active').eq(0).text(); } openSearch(keyword) return; } // TODO 上下键选择待选答案 var bl = moveChange(event); if(bl){ keywordChange(keyword); } }).on('blur', function () { // 推荐结果跳转 $('#search_result').on('click', 'li', function () { var word = $(this).text(); $('#search_keyword').val(word); openSearch(word); $('#search_result').hide(); }); // 解决失焦和点击事件冲突问题 setTimeout(function() { $('#search_result').hide(); }, 100) }).on('focus', function () { var keyword = $(this).val(); keywordChange(keyword); }); function moveChange(e){ var k = e.keyCode || e.which; var bl = true; switch(k){ case 38: rowMove('top'); bl = false; break; case 40: rowMove('down'); bl = false; break; } return bl; } function rowMove(move){ var search_result = $('#search_result'); var hove_li = null; search_result.find('.result-item').each(function(){ if($(this).hasClass('active')){ hove_li = $(this).index(); } }); if(move == 'top'){ if(hove_li==null){ hove_li = search_result.find('.result-item').length-1; }else{ hove_li--; } }else if(move == 'down'){ if(hove_li==null){ hove_li = 0; }else{ hove_li==search_result.find('.result-item').length-1?(hove_li=0):(hove_li++); } } search_result.find('.active').removeClass('active'); search_result.find('.result-item').eq(hove_li).addClass('active'); $('#search_keyword').val(search_result.find('.result-item').eq(hove_li).addClass('active').text()); } function keywordChange(keyword) { if (keyword === '') { $(document).trigger(EVENT_CLEAR_KEYWORD); } else { $(document).trigger(EVENT_SEARCH, keyword); $('#clear_keyword').show(); } } // 清空输入框 $('#clear_keyword').on('click', function () { $('#search_keyword').val(''); $('#search_keyword').focus(); $(document).trigger(EVENT_CLEAR_KEYWORD); }); // 点击高亮显示 $('#search_keyword').on('focus', function () { $('.search-left').css( { \"border-style\":\"solid\", \"border-color\": \"rgba(24, 144, 255, 1)\", \"box-shadow\": \"0px 0px 2px 1px rgba(145, 213, 255, 0.96)\", } ); }).on('blur', function () { $('.search-left').prop('style',''); }); // 搜索 $('#search_submit').on('click', function () { var keyword = $('#search_keyword').val(); var type = getSeachType(); var baseUrl = search_types.find(function (item) { return item.type === type; }); if (baseUrl && keyword) { window.open(baseUrl.url + keyword); } }); $(document).on(EVENT_CLEAR_KEYWORD, function () { $('#clear_keyword').hide(); $('#search_result').hide(); }); $(document).on(EVENT_SEARCH, function (e, keyword) { getSearchResult(keyword); }); // 获取搜索引擎类型 function getSeachType() { return $('#search_logo').data('type'); } // google 搜索结果 function searchResultGoogle(data) { var result = data[1]; result = result.map(function (item) { return item[0]; }); renderSearchResult(result); } // 百度 搜索结果 function searchResultBaidu(data) { if (data === undefined) { return; } var result = data.s; renderSearchResult(result); } // 渲染搜索结果 function renderSearchResult(array) { var $result = $('#search_result'); $result.empty().hide(); if (!array || array.length"},{"title":"","date":"2020-12-07T23:59:33.695Z","updated":"2020-12-06T08:45:45.764Z","comments":true,"path":"life/static/css/style.css","permalink":"http://qincji.gitee.io/life/static/css/style.css","excerpt":"","text":"/* ================ reset 样式 start ================ */ * { margin: 0; padding: 0; font-family: \"微软雅黑\"; -webkit-box-sizing: border-box; -moz-box-sizing: border-box; box-sizing: border-box; } body, ul, li, h1, h2, h3, h4, h5, h6, p, form, dl, dt, dd { margin: 0px; padding: 0px; font-size: 14px; font-weight: normal; } img { border-style: none; } li { list-style: none; } a { text-decoration: none } html, body { background: #fff; height: 100%; } input[type=\"button\"], input[type=\"submit\"], input[type=\"reset\"] { -webkit-appearance: none; outline: 0; } textarea { -webkit-appearance: none; } /* ================ reset 样式 end ================ */ .inner-center { width: 1000px; margin: 0 auto; } .main { padding-top: 1%; min-height: 100%; right: 2%; float: right; width: 300px; } .content-inside{ padding-bottom: 60px; } .footer { height: 60px; text-align: center; margin-top: -60px; /* position: relative; margin-top: -100px; clear:both; */ } /* logo start */ .logo-box { display: flex; overflow: hidden; margin-left: 250px; align-items: center; } .logo-left { position: relative; width: 125px; height: 121px; cursor: pointer; } .logo-right { padding-left: 36px; font-size: 36px; color: rgba(0, 39, 102, 1); font-family: SourceHanSansSC-regular; } /* logo end */ /* 搜索框 start */ .search-section { margin-top: 14px; margin-bottom: 40px; } .search-section { position: relative; display: flex; } .search-left { display: flex; width: 877px; height: 54px; line-height: 20px; border: 1px solid rgba(217, 217, 217, 0.96); } .search-logo { width: 40px; align-items: center; justify-content: center; background: url(\"./img/scgoogle.png\") center center no-repeat; filter: grayscale(100%); -webkit-filter: grayscale(100%); -moz-filter: grayscale(100%); -o-filter: grayscale(100%); filter: alpha(opacity=20); -moz-opacity: 0.2; -khtml-opacity: 0.2; opacity: 0.2; cursor: pointer; } .search-logo:hover { filter: grayscale(0%); -webkit-filter: grayscale(0%); -moz-filter: grayscale(0%); -o-filter: grayscale(0%); filter: alpha(opacity=100); -moz-opacity: 1; -khtml-opacity: 1; opacity: 1; } .search-methods { display: none; position: absolute; left: 0; top: 54px; width: 155px; border: 1px solid rgba(217, 217, 217, 0.96); background-color: #fff; } .search-methods li { padding-left: 39px; background: url(\"./img/scgoogle.png\") 10px no-repeat; overflow: hidden; height: 34px; line-height: 34px; color: #545454; cursor: pointer; } .search-logo.baidu, li.baidu { background-image: url(\"./img/scbaidu.png\"); } .search-logo.bing, li.bing { background-image: url(\"./img/scbing.png\"); } .search-logo.sogou, li.sogou { background-image: url(\"./img/scsogou.png\"); } .search-logo.wangpan, li.wangpan { background-image: url(\"./img/scwangpan.png\"); } .search-logo.so, li.so { background-image: url(\"./img/scso.png\"); } .search-logo.google, li.google { background-image: url(\"./img/scgoogle.png\"); } .search-methods .search-item:hover { background-color: #f0f0f0; } .search-result { display: none; position: absolute; width: 837px; top: 55px; left: 40px; border: 1px solid rgba(187, 187, 187, 1); background-color: #fff; } .result-item { height: 34px; line-height: 34px; padding-left: 15px; } .result-item.active { background: #F0F0F0; } .result-item:hover { background-color: #eee; cursor: pointer; } .input-wrap { position: relative; flex: 1; } .input-wrap .search-input { height: 52px; width: 100%; outline: 0; border: 0; font-size: 16px; padding-left: 15px; } /* .input-wrap .search-input:focus{ border-style:solid; border-color: #FDA31E 96%; box-shadow: 0 0 10px #FDA31E; } */ /* .search-left:focus{ border-style:solid; border-color: #FDA31E 96%; box-shadow: 0 0 10px #FDA31E; } */ .input-wrap .clear-keyword { display: none; position: absolute; top: 50%; right: 10px; transform: translateY(-50%); cursor: pointer; color: #d2d2d2; font-size: 30px; } .search-submit { width: 123px; height: 54px; line-height: 26px; /* background: url(\"./img/search.png\") #1890ff 48px center no-repeat; */ background-color: #279fb5; /* background-image: url(\"./img/search.png\"); background-size: 48px; */ background-repeat: no-repeat; background-position: center; -webkit-background-size: 35px 35px; background-size: 35px 35px; color: #fff; font-size: 18px; font-weight: 500; text-align: center; font-family: Roboto; border: 1px solid #1890ff; cursor: pointer; background: linear-gradient(90deg, #87b6e2, #0b9be9); } /* 搜索框 end */ /* 导航内容 start */ .nav-content { overflow: hidden; } /* 导航内容 end */ /*内容区域*/ /*-----------------------------简洁版样式定义- 开始---------------------------------------------------*/ .jj-list { width: 33.33%; float: left; margin-bottom: 30px; padding-right: 16px; } .jj-list:nth-of-type(3n) { padding-right: 0; } .jj-list-tit { font-size: 16px; line-height: 25px; color: rgba(49, 70, 89, 1); font-weight: bold; } .jj-list-con { overflow: hidden; margin: 0 auto; } .jj-list-con li { box-sizing: border-box; /*以IE盒子模型的width为标准*/ padding: 1px 1px; /*设置div的内边距*/ width: 33.33%; /*div等分成4部分*/ float: left; transform-origin: center top; } .jj-list-con li:hover { animation: swing 2s linear 0s 1 forwards } @keyframes swing { 0%, 100% { transform: perspective(200px) rotateX(0); } 20% { transform: perspective(200px) rotateX(-45deg); } 40% { transform: perspective(200px) rotateX(45deg); } 50% { transform: perspective(200px) rotateX(-25deg); } 60% { transform: perspective(200px) rotateX(25deg); } 70% { transform: perspective(200px) rotateX(-5deg); } 80% { transform: perspective(200px) rotateX(5deg); } 90% { transform: perspective(200px) rotateX(-3deg); } 95% { transform: perspective(200px) rotateX(3deg); } } .jj-list-link { display: block; background: rgba(230, 247, 255, 0.96); color:rgba(49, 70, 89, 1); font-size: 10px; text-align: center; line-height: 44px; transition: all 0.2s; border-radius: 2px; } .jj-list-link:hover { background: #1890ff 100%; font-size: 10px; font-weight: bold; color: #fff; } /*-----------------------------简洁版样式定义- 结束---------------------------------------------------*/"},{"title":"","date":"2020-12-07T23:59:33.696Z","updated":"2020-07-19T12:19:50.000Z","comments":true,"path":"life/static/js/jquery.min.js","permalink":"http://qincji.gitee.io/life/static/js/jquery.min.js","excerpt":"","text":"/*! jQuery v3.3.0 | (c) JS Foundation and other contributors | jquery.org/license */ !function(e,t){\"use strict\";\"object\"==typeof module&&\"object\"==typeof module.exports?module.exports=e.document?t(e,!0):function(e){if(!e.document)throw new Error(\"jQuery requires a window with a document\");return t(e)}:t(e)}(\"undefined\"!=typeof window?window:this,function(e,t){\"use strict\";var n=[],r=e.document,i=Object.getPrototypeOf,o=n.slice,a=n.concat,s=n.push,u=n.indexOf,l={},c=l.toString,f=l.hasOwnProperty,p=f.toString,d=p.call(Object),h={},g=function e(t){return\"function\"==typeof t&&\"number\"!=typeof t.nodeType},y=function e(t){return null!=t&&t===t.window},v={type:!0,src:!0,noModule:!0};function m(e,t,n){var i,o=(t=t||r).createElement(\"script\");if(o.text=e,n)for(i in v)n[i]&&(o[i]=n[i]);t.head.appendChild(o).parentNode.removeChild(o)}function x(e){return null==e?e+\"\":\"object\"==typeof e||\"function\"==typeof e?l[c.call(e)]||\"object\":typeof e}var b=\"3.3.0\",w=function(e,t){return new w.fn.init(e,t)},T=/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g;w.fn=w.prototype={jquery:\"3.3.0\",constructor:w,length:0,toArray:function(){return o.call(this)},get:function(e){return null==e?o.call(this):e1?(n=[e,e,\"\",t],r.setFilters.hasOwnProperty(e.toLowerCase())?se(function(e,n){var r,o=i(e,t),a=o.length;while(a--)e[r=O(e,o[a])]=!(n[r]=o[a])}):function(e){return i(e,0,n)}):i}},pseudos:{not:se(function(e){var t=[],n=[],r=s(e.replace(B,\"$1\"));return r[b]?se(function(e,t,n,i){var o,a=r(e,null,i,[]),s=e.length;while(s--)(o=a[s])&&(e[s]=!(t[s]=o))}):function(e,i,o){return t[0]=e,r(t,null,o,n),t[0]=null,!n.pop()}}),has:se(function(e){return function(t){return oe(e,t).length>0}}),contains:se(function(e){return e=e.replace(Z,ee),function(t){return(t.textContent||t.innerText||i(t)).indexOf(e)>-1}}),lang:se(function(e){return U.test(e||\"\")||oe.error(\"unsupported lang: \"+e),e=e.replace(Z,ee).toLowerCase(),function(t){var n;do{if(n=g?t.lang:t.getAttribute(\"xml:lang\")||t.getAttribute(\"lang\"))return(n=n.toLowerCase())===e||0===n.indexOf(e+\"-\")}while((t=t.parentNode)&&1===t.nodeType);return!1}}),target:function(t){var n=e.location&&e.location.hash;return n&&n.slice(1)===t.id},root:function(e){return e===h},focus:function(e){return e===d.activeElement&&(!d.hasFocus||d.hasFocus())&&!!(e.type||e.href||~e.tabIndex)},enabled:de(!1),disabled:de(!0),checked:function(e){var t=e.nodeName.toLowerCase();return\"input\"===t&&!!e.checked||\"option\"===t&&!!e.selected},selected:function(e){return e.parentNode&&e.parentNode.selectedIndex,!0===e.selected},empty:function(e){for(e=e.firstChild;e;e=e.nextSibling)if(e.nodeType=3?[null,e,null]:L.exec(e))||!i[1]&&t)return!t||t.jquery?(t||n).find(e):this.constructor(t).find(e);if(i[1]){if(t=t instanceof w?t[0]:t,w.merge(this,w.parseHTML(i[1],t&&t.nodeType?t.ownerDocument||t:r,!0)),A.test(i[1])&&w.isPlainObject(t))for(i in t)g(this[i])?this[i](t[i]):this.attr(i,t[i]);return this}return(o=r.getElementById(i[2]))&&(this[0]=o,this.length=1),this}return e.nodeType?(this[0]=e,this.length=1,this):g(e)?void 0!==n.ready?n.ready(e):e(w):w.makeArray(e,this)}).prototype=w.fn,q=w(r);var H=/^(?:parents|prev(?:Until|All))/,O={children:!0,contents:!0,next:!0,prev:!0};w.fn.extend({has:function(e){var t=w(e,this),n=t.length;return this.filter(function(){for(var e=0;e1&&(O[e]||w.uniqueSort(i),H.test(e)&&i.reverse()),this.pushStack(i)}});var M=/[^\\x20\\t\\r\\n\\f]+/g;function R(e){var t={};return w.each(e.match(M)||[],function(e,n){t[n]=!0}),t}w.Callbacks=function(e){e=\"string\"==typeof e?R(e):w.extend({},e);var t,n,r,i,o=[],a=[],s=-1,u=function(){for(i=i||e.once,r=t=!0;a.length;s=-1){n=a.shift();while(++s-1)o.splice(n,1),n-1:o.length>0},empty:function(){return o&&(o=[]),this},disable:function(){return i=a=[],o=n=\"\",this},disabled:function(){return!o},lock:function(){return i=a=[],n||t||(o=n=\"\"),this},locked:function(){return!!i},fireWith:function(e,n){return i||(n=[e,(n=n||[]).slice?n.slice():n],a.push(n),t||u()),this},fire:function(){return l.fireWith(this,arguments),this},fired:function(){return!!r}};return l};function I(e){return e}function W(e){throw e}function $(e,t,n,r){var i;try{e&&g(i=e.promise)?i.call(e).done(t).fail(n):e&&g(i=e.then)?i.call(e,t,n):t.apply(void 0,[e].slice(r))}catch(e){n.apply(void 0,[e])}}w.extend({Deferred:function(t){var n=[[\"notify\",\"progress\",w.Callbacks(\"memory\"),w.Callbacks(\"memory\"),2],[\"resolve\",\"done\",w.Callbacks(\"once memory\"),w.Callbacks(\"once memory\"),0,\"resolved\"],[\"reject\",\"fail\",w.Callbacks(\"once memory\"),w.Callbacks(\"once memory\"),1,\"rejected\"]],r=\"pending\",i={state:function(){return r},always:function(){return o.done(arguments).fail(arguments),this},\"catch\":function(e){return i.then(null,e)},pipe:function(){var e=arguments;return w.Deferred(function(t){w.each(n,function(n,r){var i=g(e[r[4]])&&e[r[4]];o[r[1]](function(){var e=i&&i.apply(this,arguments);e&&g(e.promise)?e.promise().progress(t.notify).done(t.resolve).fail(t.reject):t[r[0]+\"With\"](this,i?[e]:arguments)})}),e=null}).promise()},then:function(t,r,i){var o=0;function a(t,n,r,i){return function(){var s=this,u=arguments,l=function(){var e,l;if(!(t=o&&(r!==W&&(s=void 0,u=[e]),n.rejectWith(s,u))}};t?c():(w.Deferred.getStackHook&&(c.stackTrace=w.Deferred.getStackHook()),e.setTimeout(c))}}return w.Deferred(function(e){n[0][3].add(a(0,e,g(i)?i:I,e.notifyWith)),n[1][3].add(a(0,e,g(t)?t:I)),n[2][3].add(a(0,e,g(r)?r:W))}).promise()},promise:function(e){return null!=e?w.extend(e,i):i}},o={};return w.each(n,function(e,t){var a=t[2],s=t[5];i[t[1]]=a.add,s&&a.add(function(){r=s},n[3-e][2].disable,n[3-e][3].disable,n[0][2].lock,n[0][3].lock),a.add(t[3].fire),o[t[0]]=function(){return o[t[0]+\"With\"](this===o?void 0:this,arguments),this},o[t[0]+\"With\"]=a.fireWith}),i.promise(o),t&&t.call(o,o),o},when:function(e){var t=arguments.length,n=t,r=Array(n),i=o.call(arguments),a=w.Deferred(),s=function(e){return function(n){r[e]=this,i[e]=arguments.length>1?o.call(arguments):n,--t||a.resolveWith(r,i)}};if(t0||F.resolveWith(r,[w]))}}),w.ready.then=F.then;function _(){r.removeEventListener(\"DOMContentLoaded\",_),e.removeEventListener(\"load\",_),w.ready()}\"complete\"===r.readyState||\"loading\"!==r.readyState&&!r.documentElement.doScroll?e.setTimeout(w.ready):(r.addEventListener(\"DOMContentLoaded\",_),e.addEventListener(\"load\",_));var z=function(e,t,n,r,i,o,a){var s=0,u=e.length,l=null==n;if(\"object\"===x(n)){i=!0;for(s in n)z(e,t,s,n[s],!0,o,a)}else if(void 0!==r&&(i=!0,g(r)||(a=!0),l&&(a?(t.call(e,r),t=null):(l=t,t=function(e,t,n){return l.call(w(e),n)})),t))for(;s1,null,!0)},removeData:function(e){return this.each(function(){K.remove(this,e)})}}),w.extend({queue:function(e,t,n){var r;if(e)return t=(t||\"fx\")+\"queue\",r=J.get(e,t),n&&(!r||Array.isArray(n)?r=J.access(e,t,w.makeArray(n)):r.push(n)),r||[]},dequeue:function(e,t){t=t||\"fx\";var n=w.queue(e,t),r=n.length,i=n.shift(),o=w._queueHooks(e,t),a=function(){w.dequeue(e,t)};\"inprogress\"===i&&(i=n.shift(),r--),i&&(\"fx\"===t&&n.unshift(\"inprogress\"),delete o.stop,i.call(e,a,o)),!r&&o&&o.empty.fire()},_queueHooks:function(e,t){var n=t+\"queueHooks\";return J.get(e,n)||J.access(e,n,{empty:w.Callbacks(\"once memory\").add(function(){J.remove(e,[t+\"queue\",n])})})}}),w.fn.extend({queue:function(e,t){var n=2;return\"string\"!=typeof e&&(t=e,e=\"fx\",n--),arguments.length"}],"posts":[{"title":"直播推流全过程：总纲","slug":"直播推流全过程：总纲","date":"2020-12-08T05:30:20.000Z","updated":"2020-12-08T06:40:53.381Z","comments":true,"path":"2020/12/08/直播推流全过程：总纲/","link":"","permalink":"http://qincji.gitee.io/2020/12/08/%E7%9B%B4%E6%92%AD%E6%8E%A8%E6%B5%81%E5%85%A8%E8%BF%87%E7%A8%8B%EF%BC%9A%E6%80%BB%E7%BA%B2/","excerpt":"","text":"本系列介绍了rtmp直播推流全过程 完整的项目地址 以下文章是针对每一个情况，介绍音视频相关知识，以及实现的原理，总共分五章： 第一章：直播推流全过程：视频数据源之YUV（1） RGB或YUV 组成一张画面，很多个的画面就可以组成一个视频，而在视频编解码领域中YUV则是这一切的基础。 第二章：直播推流全过程：音频数据源之PCM（2） 音频处理就是对声音特性采集成数字信号后进行处理，而PCM则是最原始采集到的数据，称“裸流”。 第三章：直播推流全过程：视频编码之H.264（3） 为了减少视频大小，以及改善网络传输，H.264编码在网络传输中可是非常重要。 第四章：直播推流全过程：音频编码之AAC（4） acc编码是音频公认的主流编码。 第五章：直播推流全过程：直播推流编码之RTMP（5） 结合rtmp分块的特性，把数据较大的视频数据进行分块传输，这必定是直播界的宠儿！","categories":[],"tags":[{"name":"直播推流全过程","slug":"直播推流全过程","permalink":"http://qincji.gitee.io/tags/%E7%9B%B4%E6%92%AD%E6%8E%A8%E6%B5%81%E5%85%A8%E8%BF%87%E7%A8%8B/"}]},{"title":"直播推流全过程：直播推流编码之RTMP（5）","slug":"直播推流全过程：直播推流编码之RTMP","date":"2020-12-08T05:10:30.000Z","updated":"2020-12-08T04:47:32.916Z","comments":true,"path":"2020/12/08/直播推流全过程：直播推流编码之RTMP/","link":"","permalink":"http://qincji.gitee.io/2020/12/08/%E7%9B%B4%E6%92%AD%E6%8E%A8%E6%B5%81%E5%85%A8%E8%BF%87%E7%A8%8B%EF%BC%9A%E7%9B%B4%E6%92%AD%E6%8E%A8%E6%B5%81%E7%BC%96%E7%A0%81%E4%B9%8BRTMP/","excerpt":"","text":"简述 Adobe 公司的实时消息传输协议 (RTMP) 通过一个可靠地流传输提供了一个双向多通道消息服务，意图在通信端之间传递带有时间信息的视频、音频和数据消息流。 Handshake Diagram（握手流程） Uninitialized (未初始化)： 客户端发送C0包(1 字节，版本信息)，如果服务器支持这个版本会响应S0和S1，否则终止连接。 Version Sent (版本已发送)： 当服务器接收到版本号后(已发送S0和S1)，客户端等S1，服务器等C1，当都接收后，客户端发送C2，服务器发送S2，然后两者状态变成Ack Sent。 Ack Sent (确认已发送)： 客户端和服务器分别等待 S2 和 C2。 Handshake Done (握手结束)： 客户端和服务器可以开始交换消息了。 分块 网络传输过程中，每一个块（每个rtmp包）必须被完全发送才可以发送下一块，而在接收端，这些块被根据 chunk stream ID 被组装成消息。分块允许上层协议将大的消息分解为更小的消息，例如，防止体积大的但优先级小的消息 (比如视频) 阻碍体积较小但优先级高的消息 (比如音频或者控制命令)。分块也让我们能够使用较小开销发送小消息，因为块头包含包含在消息内部的信息压缩提示。下面块格式就是一个块的组成。（注意：当连续接收到chunk stream ID 相同时，这些快是同一个消息，需要合并。） Chunk Format（块格式） 下图大致的概括了一块的组成，从当前块的 第一个字节 大致能分析出该块头的组成信息。 Extended Timestamp 和 Chunk Data具体计算在下面介绍。 Basic Header（块基本头） cs id保留0和1的值，而2的值保留用于下层协议控制消息和命令；具体如下： 第一个字节低6bit值&gt;1： Basic Header 为1byte；fmt=2bit；cs id =6bit，范围：2-63（也就是6bit最大能支持的范围）。 fmt cs id 高2bit 低6bit 如：0100 1010-&gt;fmt：01… …=2；cs id：…00 1010=10 第一个字节低6bit值=0： Basic Header 为2byte；fmt=2bit；此时第一个字节中后6bit的值为0，cs id=第2个byte，范围：64 ~ 319（也就是第2个byte的值 + 64）。 fmt 0 cs id - 64 高2bit 低6bit byte 如：1000 0000 0001 0001-&gt;fmt：10… …=2；0：…00 0000；cs id：(0001 0001)+64=17+64=81 第一个字节低6bit值=1： Basic Header 为3byte；fmt=2bit；此时第一个字节中后6bit的值为0，cs id=第2个byte，范围：64~65599（(第3个byte) * 256 + (第2个byte) + 64）。 fmt 1 cs id - 64 高2bit 低6bit 2byte 如：1100 0000 0001 0001 0010 0010-&gt;fmt：11… …=2；1：…00 0001；cs id：(0010 0010)x256 + (0001 0001)+64=8704 + 17 + 64=8785 Message Header（块消息头） 根据块基本头中的 fmt 的值来区分块消息头，从0—3共4种，上图标的很明确了，具体如下： fmt = 0： 块消息头为11字节，当前消息的 timestamp 在这表示(此时 Extended Timestamp 辅助用)，如果用户设置时间戳&gt;=0xFFFFFF时(3字节容不下了)时，timestamp 字段就固定为0xFFFFFF。message length 是指 Chunk Data 的大小。Extended Timestamp 字段用4字节表示； timestamp message length message type id message stream id 3byte 3byte 1byte 4byte fmt = 1： 块消息头为7字节，少了 message stream id ，这一块使用前一块一样的流 ID。 timestamp delta message length message type id 3byte 3byte 1byte fmt = 2： 块消息头为3字节，只有 timestamp delta ，计算方式同 fmt = 0 时一样处理；流 ID与 fmt = 1 相同。 fmt = 3： 无块消息头；流 ID与 fmt = 1 相同；当一个消息被切割成多块时，除第一块外，其他都应 fmt = 3。 Extended Timestamp（扩展时间戳） 当块消息头中的 timestamp 或者 timestamp delta 字段(3字节)容不下时(fmt = 0，1或2)，Extended Timestamp 才会被使用。 RTMPDump tmpdump 是一个用来处理 RTMP 流媒体的工具包，支持 rtmp://, rtmpt://, rtmpe://, rtmpte://, and rtmps:// 等。源码详细api以及流程图请看雷神的RTMPdump 源代码分析 1： main()函数 ，这里只是简单介绍，集成到android中使用。因为源码很少，所以直接在as中进行编译生成静态库。 （1）下载：http://rtmpdump.mplayerhq.hu/download/rtmpdump-2.3.tgz （2）把源码导入到as中，如下图所示： librtmp/CMakeLists.txt文件配置： cmake_minimum_required(VERSION 3.4.1) #预编译宏 set(CMAKE_C_FLAGS \"$&#123;CMAKE_C_FLAGS&#125; -DNO_CRYPTO\" ) #所有源文件放入 rtmp_source 变量 file(GLOB rtmp_source *.c) #编译静态库 add_library(rtmp STATIC $&#123;rtmp_source&#125; ) 项目的CMakeLists.txt文件引用编译生成的静态库 ... # 引入指定目录下的CMakeLists.txt add_subdirectory($&#123;CMAKE_SOURCE_DIR&#125;/librtmp) ... #4、链接到库文件，jni/c/c++可以引入链接到 target_link_libraries( rtmp ...) 参考 （1）rtmp_specification_1.0 （2）https://www.cnblogs.com/Kingfans/p/7083100.html （3）https://blog.csdn.net/commshare/article/details/103393461 （4）https://blog.csdn.net/leixiaohua1020/article/details/12952977","categories":[],"tags":[{"name":"直播推流全过程","slug":"直播推流全过程","permalink":"http://qincji.gitee.io/tags/%E7%9B%B4%E6%92%AD%E6%8E%A8%E6%B5%81%E5%85%A8%E8%BF%87%E7%A8%8B/"}]},{"title":"直播推流全过程：音频编码之AAC（4）","slug":"直播推流全过程：音频编码之AAC","date":"2020-12-07T14:30:15.000Z","updated":"2020-12-08T02:31:23.745Z","comments":true,"path":"2020/12/07/直播推流全过程：音频编码之AAC/","link":"","permalink":"http://qincji.gitee.io/2020/12/07/%E7%9B%B4%E6%92%AD%E6%8E%A8%E6%B5%81%E5%85%A8%E8%BF%87%E7%A8%8B%EF%BC%9A%E9%9F%B3%E9%A2%91%E7%BC%96%E7%A0%81%E4%B9%8BAAC/","excerpt":"","text":"回顾 还记得我们采集到的PCM原始数据流（俗称裸流）吗？由于PCM裸流过大，不便于储存与传输，于是就出现了针对于PCM裸流的压缩编码标准，包含AAC，MP3，AC-3 等等（wiki audio file format）；而AAC则是当前的主流。这里的AAC指的是一套编码标准（协议），而faac是一个开源的AAC编解码工具。 简述 AAC：高级音频编码(Advanced Audio Coding)，基于MPEG-2的音频编码技术，目的是取代MP3格式。2000年，MPEG-4标准出现后，AAC重新集成了其特性，为了区别于传统的MPEG-2 AAC又称为MPEG-4 AAC。 AAC的音频文件格式 AAC的音频文件格式有两种ADIF和ADTS。这两种格式主要区别：ADIF只有一个文件头，ADTS每个包前面有一个文件头。而我们重点讲解的是ADTS格式。 ADIF Audio Data Interchange Format 音频数据交换格式。这种格式的特征是可以确定的找到这个音频数据的开始，不需进行在音频数据流中间开始的解码，即它的解码必须在明确定义的开始处进行。故这种格式常用在磁盘文件中。编码格式如下： 在MPEG-2 AAC中ADIF语法规则如下： ADTS Audio Data Transport Stream 音频数据传输流。这种格式的特征是它是一个有同步字的比特流，解码可以在这个流中任何位置开始。也就是说ADTS的每一帧都有一个header和aac音频数据，这可以在网络传输的时候进行实时解码。 下图为ADTS的组成部分以及在MPEG-2 AAC的语法结构： 下图为ADTS的组成部分以及在MPEG-4 AAC的语法结构： 注：ES：全称elementary stream，这里意为编码后的音频数据。 adts_fixed_header关键参数如下： syncword 恒为 ‘1111 1111 1111’，也就是0xFFF。作为每个adts_freme的分割。 ID 使用那个MPEG版本。0：MPEG-4，1：MPEG-2。 layer 应该恒 为‘00’。 protection_absent 是否使用error_check()。0：使用，1：不使用。 profile(MPEG-4:profile_ObjectType) 见下表（左边是MPEG-2版本；右边是MPEG-4版本，Profile_ObjectType的值）： sampling_frequency_index 采样率的数组下标，即：sampling frequeny[sampling_frequency_index] ： private_bit 私有位，编码时设置为0，解码时忽略。 channel_configuration 声道数。 original_copy 编码时设置为0，解码时忽略。 home 编码时设置为0，解码时忽略。 adts_variable_header关键参数如下： copyright_identification_bit 72位版权标识字段中的一位。 copyright_identification_start 一位表示 该音频帧中的copyright_identification_bit是 72位版权标识的第一位。如果不 版权标识已传输，此位应 保持为’0’。'0’在 此音频帧“ 1”开始在 此音频帧。 frame_length(MPEG-4:aac_frame_length) 帧的长度，包括header和以字节为单位的error_check。 adts_buffer_fullness 固定0x7FF，表示比特流是可变速率比特流。 number_of_raw_data_blocks_in_frame 在ADTS帧中有number_of_raw_data_blocks_in_frame + 1个AAC原始数据块。number_of_raw_data_blocks_in_frame == 0 表示说ADTS帧中有一个AAC原始数据块。 下图为一个ADTS格式的文件开头部分 我们来数一个第一个frame的header ####adts_fixed_header() #-------FFF1--------- 1111 1111 1111 .... #0xFFF; syncword的值 .... .... .... 0... #ID=0;使用MPEG-4 .... .... .... .00. #layer .... .... .... ...0 #protection_absent，不使用error_check() #-------4C80--------- 01.. .... .... .... #Profile_ObjectType=AAC MAIN ..00 11.. .... .... #sampling_frequency_index=3,采样率为48000 .... ..0. .... .... #private_bit .... ...0 10.. .... #channel_configuration=2（声道数） .... .... ..0. .... #original_copy .... .... ...0 .... #home ####adts_variable_header() #-------(4C8)0--------- .... .... .... 0... #copyright_identification_bit .... .... .... .0.. #copyright_identification_start #-------(4C8)0 223F-------- ..00 0010 0010 001. .... #aac_frame_length=0x111=273字节--&gt;下一帧到上图的FFF14C #-------(22)3F FC-------- ...1 1111 1111 11.. #adts_buffer_fullness=0x7FF #-------(F)C-------- ..00 #number_of_raw_data_blocks_in_frame faac开源库 （1）下载 https://nchc.dl.sourceforge.net/project/faac/faac-src/faac-1.29/faac-1.29.9.2.tar.gz （2）编译生成静态库（这里是android的交叉编译脚本，ndk21，平台mac） #!/bin/bash PREFIX=`pwd`/android/armeabi-v7a NDK_ROOT=/Users/Qincji/Desktop/develop/android/source/sdk/ndk/android-ndk-r21 # 注意：Mac为darwin-x86_64，linux为linux-x86_64；一定要确保路径真实有效 TOOLCHAIN=$NDK_ROOT/toolchains/llvm/prebuilt/darwin-x86_64 CROSS_COMPILE=$TOOLCHAIN/bin/arm-linux-androideabi #在android studio中新建一个NDK项目，并且保持NDK版本与这里的一致。该FLAGS从build.ninja文件中拷贝。 FLAGS=\"-g -DANDROID -fdata-sections -ffunction-sections -funwind-tables -fstack-protector-strong -no-canonical-prefixes -D_FORTIFY_SOURCE=2 -march=armv7-a -mthumb -Wformat -Werror=format-security -Oz -DNDEBUG -fPIC\" export CC=$TOOLCHAIN/bin/armv7a-linux-androideabi21-clang export CXX=$TOOLCHAIN/bin/armv7a-linux-androideabi21-clang++ export CFLAGS=\"$FLAGS\" export PATH=$PATH:$TOOLCHAIN/bin ./configure \\ --prefix=$PREFIX \\ --host=arm-linux-androideabi \\ --with-pic \\ --enable-shared=no make clean make install （3）移入项目中 并且配置CMakeList.txt文件 ... include_directories(include) ... target_link_libraries( ... faac ) （4）API简单使用 //1.打开编码器，获取inputSamples和maxOutputBytes的值，用于后面编码 //1：采样率；2：声道数；3：单次输入的样本数；4：输出数据最大字节数 faacEncOpen(unsigned long sampleRate,unsigned int numChannels,unsigned long *inputSamples,unsigned long *maxOutputBytes); //2.设置编码器参数 faacEncConfigurationPtr config = faacEncGetCurrentConfiguration(faacEncHandle hEncoder); //指定mpeg4编码标准 config-&gt;mpegVersion = MPEG4; //config-&gt;mpegVersion = MPEG2; //lc 标准 config-&gt;aacObjectType = LOW; //16位 config-&gt;inputFormat = FAAC_INPUT_16BIT; // 编码出原始数据；0 = Raw; 1 = ADTS config-&gt;outputFormat = 1; faacEncSetConfiguration(faacEncHandle hEncoder, config); //3.进行编码 //1：FAAC的handle；2：采集的pcm的原始数据；3：从faacEncOpen获取的inputSamples；4：至少有从faacEncOpen获取maxOutputBytes大小的缓冲区；5：从faacEncOpen获取maxOutputBytes //返回值为编码后数据字节的长度 int encodeLenght = faacEncEncode(faacEncHandle hEncoder, int32_t * inputBuffer, unsigned int samplesInput, unsigned char *outputBuffer, unsigned int bufferSize); 参考 AAC格式简介 wiki audio file format https://csclub.uwaterloo.ca/~ehashman/ISO14496-3-2009.pdf [AAC ADTS格式分析](","categories":[],"tags":[{"name":"直播推流全过程","slug":"直播推流全过程","permalink":"http://qincji.gitee.io/tags/%E7%9B%B4%E6%92%AD%E6%8E%A8%E6%B5%81%E5%85%A8%E8%BF%87%E7%A8%8B/"}]},{"title":"直播推流全过程：视频编码之H.264（3）","slug":"直播推流全过程：视频编码之H264","date":"2020-12-06T08:54:50.000Z","updated":"2020-12-08T05:54:00.715Z","comments":true,"path":"2020/12/06/直播推流全过程：视频编码之H264/","link":"","permalink":"http://qincji.gitee.io/2020/12/06/%E7%9B%B4%E6%92%AD%E6%8E%A8%E6%B5%81%E5%85%A8%E8%BF%87%E7%A8%8B%EF%BC%9A%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81%E4%B9%8BH264/","excerpt":"","text":"简单说说编码 当我们把摄像头采集画面直接写入到文件中时，我们会发现没一会文件已经非常大了。这导致很不适合保存和传输，所以需要编码，把画面数据进行压缩。视频编码标准有很多，而我们这里讲的是H.264编码。其他请看：视频编码标准汇总及比较。 H.264编码 制订H.264的主要目标有两个： （1）视频编码层(VCL，全称：Video Coding Layer)：得到高的视频压缩比。 （2）网络提取层(NAL，全称：Network Abstraction Layer)：具有良好的网络亲和性，即可适用于各种传输网络。而NAL则是以NALU（NAL Unit）为单元来支持编码数据在基于包交换技术网络中传输的。 编码的输入与输出 一张张画面通过以H.264编码标准的编码器(如x264)编码后，输出一段包含N个NALU的数据，每个NALU之间通过起始码来分隔，如图： 起始码： 0x00 00 01 或者 0x00 00 00 01。 在网络传输（如RTMP）或者一些容器中（如FLV），通常会把NALU整合到视频区域的数据中。如下图的flv格式： 所以这篇文章主要学习NALU的基本知识，学会如何去分析一段NALU数据。 NALU（NAL 单元） NALU(NAL Unit，NAL 单元)的组成部分如下图。其中，f(0)占1bit，u(2)占2bit，u(5)占5bit，文中如有出现类似描述符请看H.264描述符。 从上图可以看出来，当前NAL单元属于什么样的类型，这取决于RBSP具体是什么样的类型，而RBSP的类型是根据nal_unit_type的值来定义的。 ①当nal_unit_type为1~5时：RBSP为切片类型（有5种切片类型）；整个NAL单元类型为VCL NAL单元，VCL是上面说的视频编码层，里面有编码后画面数据。 ②当nal_unit_type为其他时：RBSP为序列参数集类型、图像参数集类型等等；整个NAL单元类型为非VCL NAL单元。 具体的nal_unit_type所对应的RBSP类型如下表所示： nal_unit_type NAL 单元和 RBSP 语法结构的内容 0 未指定 1 一个非IDR图像的编码条带slice_layer_without_partitioning_rbsp( ) 2 编码条带数据分割块Aslice_data_partition_a_layer_rbsp( ) 3 编码条带数据分割块Bslice_data_partition_b_layer_rbsp( ) 4 编码条带数据分割块Cslice_data_partition_c_layer_rbsp( ) 5 IDR图像的编码条带slice_layer_without_partitioning_rbsp( ) 6 辅助增强信息 (SEI)sei_rbsp( ) 7 序列参数集（SPS）seq_parameter_set_rbsp( ) 8 图像参数集(PPS)pic_parameter_set_rbsp( ) 9 访问单元分隔符access_unit_delimiter_rbsp( ) 10 序列结尾end_of_seq_rbsp( ) 11 流结尾end_of_stream_rbsp( ) 12 填充数据filler_data_rbsp( ) 13 序列参数集扩展seq_parameter_set_extension_rbsp( ) 14…18 保留 19 未分割的辅助编码图像的编码条带slice_layer_without_partitioning_rbsp( ) 20…23 保留 24…31 未指定 SPS（序列参数集） SPS全称 Sequence parameter set(序列参数集)，当nal_unit_type=7时，RBSP就是SPS类型，也可以说NAL单元为SPS的NAL单元。SPS主要包含的是针对一连续编码视频序列的参数，如帧数、图像尺寸等；详见下表 序列参数集RBSP 语法： 上面中的主要参数的含义： profile_idc 档次（H.264编码标准有几个档次）：66=基本；77=主要；88=扩展… seq_parameter_set_id 标识符，本序列的id号，会被PPS引用。 num_ref_frames 指定参考帧队列可能达到的最大长度。 pic_width_in_mbs_minus1 加1是指以宏块为单元的每个解码图像的宽度。 pic_height_in_map_units_minus1 加1表示以条带组映射为单位的一个解码帧或场的高度。 下面为从一个只放h.264视频编码文件的一段（SPS）： ue(v)和se(v)的计算公式见 H.264描述符。 # 00000001 6764001E ACD940A0 2FF96100 00030001 00000300 320F162D 96 00000001 #起始码 #NAL单元头---0x67 0110 0111 -------------- 0... .... # forbidden_zero_bit --&gt;u(1) .11. .... # nal_ref_idc --&gt;u(2) --&gt;HIGHEST ...0 0111 # nal_unit_type --&gt;u(5) --&gt;SPS 64 # profile_idc=103 --&gt;u(8) #---0x00 0000 0000 -------------- 0... .... #constraint_set0_flag .0.. .... #constraint_set1_flag ..0. .... #constraint_set2_flag ...0 .... #constraint_set3_flag .... 0000 #reserved_zero_4bits 1E # level_idc --&gt;u(8) --&gt; 30 #-----------0xAC 1010 1100 -------------- 1... .... # seq_parameter_set_id --&gt; ue(v) --&gt; 0 .010 .... # log2_max_frame_num_minus4 --&gt; ue(v) --&gt; 1 .... 1... # pic_order_cnt_type --&gt; ue(v) --&gt;1 执行else if( pic_order_cnt_type == 1 ) .... .1..#delta_pic_order_always_zero_flag --&gt;u(1) #----------0xACD9 (1010 11)00 1101 1001 ====== 括号里面的bit上面已使用 .... ..00 110. .... #offset_for_non_ref_pic --&gt;se(v)-&gt;codeNum=5-&gt;value=3 .... .... ...1 .... #offset_for_top_to_bottom_field --&gt;se(v)-&gt;codeNum=0-&gt;value=0 .... .... .... 1... #num_ref_frames_in_pic_order_cnt_cycle --&gt;ue(v)-&gt;0 #----------0xD940 (1101 1)001 0100 0000 ====== 括号里面的bit上面已使用 .... .001 01.. .... #num_ref_frames --&gt;ue(v)-&gt;4 .... .... ..0. .... #gaps_in_frame_num_value_allowed_flag --&gt;u(1)-&gt;0 #----------0x40A0 (010)0 0000 1010 0000 ====== 括号里面的bit上面已使用 ...0 0000 1010 00.. #pic_width_in_mbs_minus1 --&gt;ue(v)-&gt;32-1+8=39 #----------0xA02F (1010 00)00 0010 1111 ====== 括号里面的bit上面已使用 .... ..00 0010 111. #pic_height_in_map_units_minus1 --&gt;ue(v)-&gt;16-1+7=22 …………就到这里了，偷个懒，有兴趣大家自己分析下去，哈哈 PPS（图像参数集） PPS全称picture parameter set(图像参数集)，当nal_unit_type=8时，RBSP就是PPS类型，也可以说NAL单元为SPS的NAL单元。一个序列中某一幅图像或者某几幅图像，其参数如标识符pic_parameter_set_id、可选的seq_parameter_set_id、熵编码模式选择标识、片组数目、初始量化参数和去方块滤波系数调整标识等；详见下表 图像参数集RBSP 语法： X264 这是国际好评的H.264协议标准的编码工具，这里简单介绍一下如何使用。 （1）下载：https://www.videolan.org/developers/x264.html （2）编译（android的交叉编译，平台：Mac） #!/bin/sh ##########脚本忘记是参考哪位大神的了########## #ndk的路径 NDK=/Users/Qincji/Desktop/develop/android/source/sdk/ndk/android-ndk-r17c API=17 #最低支持Android版本 #编译平台darwin-x86_64为mac，linux-x86_64为linux HOST_PLATFORM=darwin-x86_64 function build_x264 &#123; OUTPUT=$(pwd)/\"android\"/\"$CPU\" ./configure \\ --prefix=$OUTPUT \\ --cross-prefix=$CROSS_PREFIX \\ --sysroot=$SYSROOT \\ --host=$HOST \\ --disable-asm \\ --disable-shared \\ --enable-static \\ --disable-opencl \\ --enable-pic \\ --disable-cli \\ --extra-cflags=\"$EXTRA_CFLAGS\" \\ --extra-ldflags=\"$EXTRA_LDFLAGS\" make clean make install echo \"编译结束，路径如下：\" echo \"$OUTPUT\" &#125; CPU=\"armeabi-v7a\" CROSS_PREFIX=$NDK/toolchains/arm-linux-androideabi-4.9/prebuilt/darwin-x86_64/bin/arm-linux-androideabi- SYSROOT=$NDK/platforms/android-$API/arch-arm/ EXTRA_CFLAGS=\"-D__ANDROID_API__=$API -isysroot $NDK/sysroot -I$NDK/sysroot/usr/include/arm-linux-androideabi -Os -fPIC -marm\" EXTRA_LDFLAGS=\"-marm\" HOST=arm-linux build_x264 （3）把编译生成的静态库移入android studio 在CMakeList.txt文件中添加： ... include_directories(include) ... target_link_libraries( ... x264 ) （4）API简单使用 /** 关键步骤，来自雷神：https://blog.csdn.net/leixiaohua1020/article/details/42078645 x264_param_default()：设置参数集结构体x264_param_t的缺省值。 x264_picture_alloc()：为图像结构体x264_picture_t分配内存。 x264_encoder_open()：打开编码器。 x264_encoder_encode()：编码一帧图像。 x264_encoder_close()：关闭编码器。 x264_picture_clean()：释放x264_picture_alloc()申请的资源。 存储数据的结构体如下所示。 x264_picture_t：存储压缩编码前的像素数据。 x264_nal_t：存储压缩编码后的码流数据。 */ int X264Rtmp::encode(const char *url, int width, int height, int bitRate, int fps) &#123; //计算一帧等信息 int ySize = width * height; int uvSize = ySize / 4; FILE *fp_src = fopen(url, \"rb\"); //初始化VLC图片编码层的参数 x264_picture_t *pic_in = (x264_picture_t *) malloc(sizeof(x264_picture_t)); x264_t *videoCodec = 0; x264_param_t param; x264_param_default(&amp;param); //根据应用场景设置编码速度，以及编码质量。2：x264_preset_names，3：x264_tune_names x264_param_default_preset(&amp;param, x264_preset_names[0], x264_tune_names[7]); //输入数据格式， yuv 4:2:0 param.i_csp = X264_CSP_I420; param.i_width = width; param.i_height = height; //base_line 3.2 编码规格，影响网络带宽，图像分辨率等。 -- https://en.wikipedia.org/wiki/Advanced_Video_Coding param.i_level_idc = 32; //两张参考图片间b帧的数量 param.i_bframe = 0; //参数i_rc_method表示码率控制，CQP(恒定质量)，CRF(恒定码率)，ABR(平均码率) param.rc.i_rc_method = X264_RC_ABR; //比特率(码率, 单位Kbps) param.rc.i_bitrate = bitRate / 1000; //瞬时最大码率 param.rc.i_vbv_max_bitrate = bitRate / 1000 * 1.2; //设置了i_vbv_max_bitrate必须设置此参数，码率控制区大小,单位kbps param.rc.i_vbv_buffer_size = bitRate / 1000; //帧率（每秒显示多少张画面） param.i_fps_num = fps; param.i_fps_den = 1; param.i_timebase_den = param.i_fps_num; param.i_timebase_num = param.i_fps_den; // param.pf_log = x264_log_default2; //用fps而不是时间戳来计算帧间距离 param.b_vfr_input = 0; //帧距离(关键帧) 2s一个关键帧 param.i_keyint_max = fps * 2; // 是否复制sps和pps放在每个关键帧的前面 该参数设置是让每个关键帧(I帧)都附带sps/pps。 param.b_repeat_headers = 1; //多线程 param.i_threads = 1; x264_param_apply_profile(&amp;param, \"baseline\"); //打开编码器 videoCodec = x264_encoder_open(&amp;param); x264_picture_alloc(pic_in, X264_CSP_I420, width, height); //编码：h264码流 while (!feof(fp_src)) &#123; //y数据 fread(pic_in-&gt;img.plane[0], ySize, 1, fp_src); //Y fread(pic_in-&gt;img.plane[1], uvSize, 1, fp_src); //U fread(pic_in-&gt;img.plane[2], uvSize, 1, fp_src); //V //编码出来的数据 （帧数据） x264_nal_t *pp_nal; //编码出来有几个数据 （多少帧） int pi_nal; x264_picture_t pic_out; x264_encoder_encode(videoCodec, &amp;pp_nal, &amp;pi_nal, pic_in, &amp;pic_out); //如果是关键帧 3 int sps_len; int pps_len; uint8_t sps[100]; uint8_t pps[100]; // chroma_format_idc for (int i = 0; i &lt; pi_nal; ++i) &#123; x264_nal_t &amp;nal = pp_nal[i]; if (nal.i_type == NAL_SPS) &#123; &#125; else if (nal.i_type == NAL_PPS) &#123; &#125; else &#123; &#125; &#125; &#125; &#125; 参考 视频编码标准汇总及比较 H.264-AVC-ISO_IEC_14496-10 新一代视频压缩编码标准-H.264_AVC(第二版) https://stackoverflow.com/questions/28421375/usage-of-start-code-for-h264-video/29103276 https://blog.csdn.net/engineer_james/article/details/81750864 x264流程 x264参数注释","categories":[],"tags":[{"name":"直播推流全过程","slug":"直播推流全过程","permalink":"http://qincji.gitee.io/tags/%E7%9B%B4%E6%92%AD%E6%8E%A8%E6%B5%81%E5%85%A8%E8%BF%87%E7%A8%8B/"}]},{"title":"我的博客搭建笔记","slug":"我的博客搭建笔记","date":"2020-12-04T14:59:35.000Z","updated":"2020-12-06T10:02:51.022Z","comments":true,"path":"2020/12/04/我的博客搭建笔记/","link":"","permalink":"http://qincji.gitee.io/2020/12/04/%E6%88%91%E7%9A%84%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E7%AC%94%E8%AE%B0/","excerpt":"","text":"选择GitHub Page的原因是比其他平台爽！ 且免费，还能拥有自己独立门户！大家用过其他平台的都不少有吐槽的地方吧？说说我搭建的过程和思路。 选择套餐（Mac平台）： Github Page + Hexo（主题：pure；插件：hexo-image-link）+ Typory （1）搭建GitHub Pages 和 Hexo ，注意点：①仓库名必须为：昵称.github.io`，访问时是：https://昵称.github.io作为首页。②主题选择下面（2）的。 （2）Hexo主题选择hexo-theme-pure，注意：①路径复制到的目录应该是下图位置；②categories文章分类并不会合并，所以我只用tags。 （3）使用Hexo插件hexo-image-link解决图片问题，以及Typory工具写markdown文章 记录hexo的几个关键命令： （1）删除自动生成的文件 hexo clean （2）生成网页等文件 hexo g （3）开启预览服务，浏览器中输入：http://localhost:4000/ hexo s （4）更新到github仓库 hexo d nmp代理 （1）方式一：安装cnpm镜像代理；安装后使用 cnpm命令代替cpm npm install -g cnpm --registry=https://registry.npm.taobao.org cnpm install -g @angular/cli （2）方式二： npm config set registry https://registry.npm.taobao.org","categories":[],"tags":[{"name":"其他","slug":"其他","permalink":"http://qincji.gitee.io/tags/%E5%85%B6%E4%BB%96/"}]},{"title":"直播推流全过程：音频数据源之PCM（2）","slug":"直播推流全过程：音频数据源之PCM","date":"2020-12-04T10:10:20.000Z","updated":"2020-12-06T09:52:52.390Z","comments":true,"path":"2020/12/04/直播推流全过程：音频数据源之PCM/","link":"","permalink":"http://qincji.gitee.io/2020/12/04/%E7%9B%B4%E6%92%AD%E6%8E%A8%E6%B5%81%E5%85%A8%E8%BF%87%E7%A8%8B%EF%BC%9A%E9%9F%B3%E9%A2%91%E6%95%B0%E6%8D%AE%E6%BA%90%E4%B9%8BPCM/","excerpt":"","text":"声音与音频 声音是波，成为声波，而声波的三要素是频率、振幅和波形。频率代表音阶的高低（女高音、男低音）单位赫兹（Hz），人耳能听到的声波范围：频率在20Hz~20kHz之间；振幅代表响度（音量）；波形代表音色。而我们音频处理就是对声波采集成数字信号后进行处理。 音频采集与关键名词 音频采集的过程主要是通过设备设置采样率、采样数，将音频信号采集为pcm（Pulse-code modulation，脉冲编码调制）编码的原始数据（无损压缩），然后编码压缩成mp3、aac等封装格式的数据。音频关键知识： 采样率： 一段音频数据中单位时间内（每秒）采样的个数。 位宽： 一次最大能传递数据的宽度，可以理解成放单个采集数据的内存。常有8位和16位，而8位：代表着每个采集点的数据都使用8位（1字节）来存储；16位：代表着每个采集点的数据都使用16位（2字节）来存储。 声道数： 扬声器的个数，单声道、双声道等。每一个声道都占一个位宽。 来一张图来描述一下： 一段时间内的数据大小如何计算？ 采样率 x (位宽 / 8) x 声道数 x 时间 = 数据大小（单位：字节） 比如 2分钟的CD（采样率为：44100，位宽：16，声道数：2）的数据大小：44100 x (16 / 8) x 2 x 120 = 20671.875 Byte 约为 20.18M。 PCM数据的基本使用 我们采集到的pcm原始数据要怎么玩？首先得知道怎么这些数据都代表啥意思，然后才能入手处理。 1、pcm数据时如何组成（存储）？ 举个例子，分别使用不同的方式存储一段采集数据 0x11 0x22 0x33 0x44 0x55 0x66 0x77 0x88 总共8个字节。 8位单声道： 按照数据采集时间顺序存储，即：0x11 0x22 0x33 0x44 0x55 0x66 0x77 0x88 8位双声道： L声道-R声道-L声道-R声道形式存储，即：0x11(L) 0x22® 0x33(L) 0x44® …… 16位单声道： 首先从 维基多媒体：pcm了解到位宽大于8位时，字节的排序方式是有差别的，描述如下： When more than one byte is used to represent a PCM sample, the byte order (big endian vs. little endian) must be known. Due to the widespread use of little-endian Intel CPUs, little-endian PCM tends to be the most common byte orientation. 当使用一个以上的字节表示PCM样本时，必须知道字节顺序（大端与小端）。由于低端字节Intel CPU的广泛使用，低端字节PCM往往是最常见的字节方向。 举个栗子：当位宽为16位（2字节）存储一个采集数据时，如：0x12ab，大端和小端分别是： big-endian: 0x12 0xab； little-endian: 0xab 0x12。 所以： big-endian存储方式：0x1122 0x3344 0x5566 0x7788； little-endian存储方式：0x2211 0x4433 0x6655 0x8877。 16位双声道： L声道-R声道-L声道-R声道形式存储： big-endian：0x1122(L) 0x3344® 0x5566(L) 0x7788® little-endian: 0x2211(L) 0x4433® 0x66550(L) 0x8877® 2、pcm原始数据可以怎么玩？ 将little-endian_2_44100_16.pcm采样数据进行切割，只保留后面5秒的数据 /** * 将little-endian_2_44100_16.pcm采样数据进行切割，只保留后面5秒的数据 * 1、该类型数据5秒有多长？ * 2、从哪里开始截取？ */ int cut5second(const char *url)&#123; FILE *in = fopen(url, \"rb+\"); FILE *out = fopen(\"./output/spit5second.pcm\", \"wb+\"); long long data5Length = 44100 * (16/8) * 2 * 5; struct stat statbuf; stat(url,&amp;statbuf); long long fileLength = statbuf.st_size; long long start = fileLength - data5Length; char *simple = (char *)malloc(data5Length); //把指针位置移动到start位置开始读取 fseek(in,start,1); //每次从in文件中读取1组data5Length个长度数据的到simple中 fread(simple,data5Length,1,in); fwrite(simple,data5Length,1,out); fclose(in); fclose(out); return 0; &#125; 分离各声道的数据：把各个声道的采集点数据分开存储。 /** * 将little-endian_2_44100_16.pcm 分离各声道的数据，即把各个声道的采集点数据分开存储。 */ int separateLR(const char *url)&#123; FILE *in = fopen(url, \"rb+\"); FILE *outL = fopen(\"./output/l.pcm\", \"wb+\"); FILE *outR = fopen(\"./output/r.pcm\", \"wb+\"); int simpleLength = 16 / 8 * 2; char *simple = (char *)malloc(simpleLength); while (1)&#123; //每次从in文件中读取1组4个长度数据的到simple中 fread(simple,4,1,in); if(feof(in))&#123; break; &#125; //l(0声道)：1-2 fwrite(simple,2,1,outL); //r(1声道)：3-4 fwrite(simple+2,2,1,outR); &#125; fclose(in); fclose(outL); fclose(outR); return 0; &#125; 音量调节：把每个采集点数据的值 x 调节比例。注意：需要注意的是可调节范围，如：8位有无符号时最大是多少。 /** * 将little-endian_2_44100_16.pcm 调节音量 比例 * 1、little-endian排序的值是如何排序的？真正的值是多少？ * 2、little-endian转成真正的值之后再进行计算，得到的结果再反转little-endian。 * 如：原始pcm数据：0xaa 0x01(左声道采样点数据)，当scale=2： * -&gt; 值：0x01aa * 2 = 0x0354 * -&gt; 转回little-endian再进行存储：0x5403（缩放后的值） */ int volumeAdjustment(const char *url, float scale)&#123; FILE *in = fopen(url, \"rb+\"); FILE *out = fopen(\"./output/volume_adjustment.pcm\", \"wb+\"); char *simple = (char *)malloc(4); while (1)&#123; //每次从in文件中读取1组4个长度数据的到simple中 fread(simple, 4, 1, in); if(feof(in))&#123; break; &#125; short *simple8bitTemp = (short *)malloc(2); //l(0声道)： simple8bitTemp[0] = (simple[0] + (simple[1] &lt;&lt; 8)) * scale; //r(1声道)： simple8bitTemp[1] = (simple[2] + (simple[3] &lt;&lt; 8)) * scale; simple[0] = simple8bitTemp[0] &amp; 0x00FF; simple[1] = simple8bitTemp[0] &gt;&gt; 8; simple[2] = simple8bitTemp[1] &amp; 0x00FF; simple[3] = simple8bitTemp[1] &gt;&gt; 8; for(int i=0; i&lt;4; i++)&#123; printf(\"simple[%d]=%d\\n\",i,simple[i]); &#125; fwrite(simple, 4, 1, out); &#125; fclose(in); fclose(out); return 0; &#125; 播放速度：按照比例丢弃（或插入0）采集点的数据即可。（涉及到不是整数倍不单单是这么处理，我也不懂） 参照雷神的必看项目： 视音频数据处理入门：PCM音频采样数据处理 。 Android终端音频采样介绍 1、关于采集的主要api介绍 /** * @param audioSource 音频来源&#123;@link MediaRecorder.AudioSource&#125;；如指定麦克风：MediaRecorder.AudioSource.MIC * @param sampleRateInHz 采样率&#123;@link AudioFormat#SAMPLE_RATE_UNSPECIFIED&#125;，单位Hz；安卓支持所有的设备是：44100Hz * @param channelConfig 声道数&#123;@link AudioFormat#CHANNEL_IN_MONO&#125;； * @param audioFormat 位宽&#123;@link AudioFormat#ENCODING_PCM_8BIT&#125; * @param bufferSizeInBytes 采集期间缓存区的大小 */ public AudioRecord(int audioSource, int sampleRateInHz, int channelConfig, int audioFormat, int bufferSizeInBytes) //获取最小缓存区，参数跟AudioRecord保持一致 int getMinBufferSize(int sampleRateInHz, int channelConfig, int audioFormat) &#123;&#125; 2、实现采集的伪代码 //1、申请权限 //2、获取最小缓存大小（根据api介绍，应该取要比预期大的缓冲区大小），这个大小其实也可以取①和②计算得来的大小 int minBufferSize = AudioRecord.getMinBufferSize(44100, AudioFormat.CHANNEL_IN_STEREO, AudioFormat.ENCODING_PCM_16BIT) * 2; //3、初始化AudioRecord对象 AudioRecord audioRecord = new AudioRecord(MediaRecorder.AudioSource.MIC, 44100, AudioFormat.CHANNEL_IN_STEREO, AudioFormat.ENCODING_PCM_16BIT, minBufferSize); //4、开始在子线程中进行采集数据 new Thread(new Runnable() &#123; @Override public void run() &#123; audioRecord.startRecording(); while(isRunning)&#123; byte[] bytes = new byte[minBufferSize]; int len = audioRecord.read(bytes, 0, bytes.length); //这里就可以把数据直接写入到sdcard了，如：xxx.pcm；输出排序方式为：little endian。 &#125; //5、停止录音机 audioRecord.stop(); &#125; &#125;).start(); //6、最后释放资源 audioRecord.release(); 播放pcm原始数据 ffmpeg： ffplay -f s16le -sample_rate 44100 -channels 2 -i xxx.pcm 其他： Adobe Audition 参考 维基多媒体：pcm 视音频数据处理入门：PCM音频采样数据处理 Android 音视频开发_何俊林（书）","categories":[],"tags":[{"name":"直播推流全过程","slug":"直播推流全过程","permalink":"http://qincji.gitee.io/tags/%E7%9B%B4%E6%92%AD%E6%8E%A8%E6%B5%81%E5%85%A8%E8%BF%87%E7%A8%8B/"}]},{"title":"直播推流全过程：H.264描述符","slug":"直播推流全过程：H.264描述符","date":"2020-12-04T04:50:20.000Z","updated":"2020-12-06T09:48:16.446Z","comments":true,"path":"2020/12/04/直播推流全过程：H.264描述符/","link":"","permalink":"http://qincji.gitee.io/2020/12/04/%E7%9B%B4%E6%92%AD%E6%8E%A8%E6%B5%81%E5%85%A8%E8%BF%87%E7%A8%8B%EF%BC%9AH.264%E6%8F%8F%E8%BF%B0%E7%AC%A6/","excerpt":"","text":"简述 H264/AVC文档中存在着大量元素描述符ue(v)，me(v)，se(v)，te(v)等，编码为ue(v)，me(v)，或者 se(v) 的语法元素是指数哥伦布编码，而编码为te(v)的语法元素是舍位指数哥伦布编码。这些语法元素的解析过程是由比特流当前位置比特开始读取，包括非0 比特，直至leading_bits 的数量为0。由于解码过程中需要计算出每个元素的占位(bit数量)，所以我们就不得不理解这些描述符了。 ue(v) 无符号整数指数哥伦布码编码的语法元素，左位在先。计算公式： ​ codeNum = 2 leadingZeroBits − 1 + read_bits( leadingZeroBits ) codeNum： 占的位数（bit数量） leadingZeroBits： 遇到第一个1前面0的个数；如：0010 1011，leadingZeroBits的值为2； read_bits( leadingZeroBits )： 遇到第一个1后面leadingZeroBits个组成的无符号二进制值；如：0010 1011，值为…0 1…，即01，即1； 举两个栗子： （1）0001 1001 =&gt;leadingZeroBits== 000. …= 3，read_bits( 3 )==… 100.=4，所以：codeNum=23-1+4=13 （2）0000 0101 0000 0000 =&gt; leadingZeroBits=5，read_bits( 5 ) = … …01 000. …=8，codeNum=25-1+8=39 se(v) 有符号整数指数哥伦布码编码的语法元素位在先。在按照上面ue(v)公式计算出codeNum后，然后使用该计算公式： value = (−1)k+1 Ceil( k÷2 ) Ceil： 返回大于或者等于指定表达式的最小整数，如： Ceil(1.5)= 2 如上例（1）0001 1001 =&gt; codeNum=23-1+4=13，value = (-1)13+1Ceil(13÷2)=Ceil(6.5)=7 me(v) 映射的指数哥伦布码编码的语法元素，左位在先。在按照上面ue(v)公式计算出codeNum后，然后查表。（在H.264-AVC-ISO_IEC_14496-10的9.1.2 章节中表9-4） te(v) 舍位指数哥伦布码编码语法元素，左位在先。明确取值范围在0-x；当x&gt;1时，te(v)就是ue(v)；否则(x=1)，b = read_bits( 1 )，codeNum = !b 其他 ae(v)： 上下文自适应算术熵编码语法元素 b(8)： 任意形式的8比特字节。 f(n)： n位固定模式比特串（由左至右），左位在先。 i(n)： 使用n比特的有符号整数。 u(n)： n位无符号整数。 参考 (1).H.264-AVC-ISO_IEC_14496-10 (2).https://blog.csdn.net/lizhijian21/article/details/80982403","categories":[],"tags":[{"name":"直播推流全过程","slug":"直播推流全过程","permalink":"http://qincji.gitee.io/tags/%E7%9B%B4%E6%92%AD%E6%8E%A8%E6%B5%81%E5%85%A8%E8%BF%87%E7%A8%8B/"}]},{"title":"直播推流全过程：视频数据源之YUV（1）","slug":"直播推流全过程：视频数据源之YUV","date":"2020-12-03T14:20:51.000Z","updated":"2020-12-06T09:57:26.241Z","comments":true,"path":"2020/12/03/直播推流全过程：视频数据源之YUV/","link":"","permalink":"http://qincji.gitee.io/2020/12/03/%E7%9B%B4%E6%92%AD%E6%8E%A8%E6%B5%81%E5%85%A8%E8%BF%87%E7%A8%8B%EF%BC%9A%E8%A7%86%E9%A2%91%E6%95%B0%E6%8D%AE%E6%BA%90%E4%B9%8BYUV/","excerpt":"","text":"视频基本概念 一个视频简单点理解就是播放一张张画面。我们就从这里面把视频的相关名词扯出来：①一张画面，一张画面也就一帧画面；属性为图像的大小或尺寸称分别率；画面的成像组成的方式有：rgb和yuv；跟计算器关联起来还不是用0101的比特来表示②当画面遇上了时间，爱的结晶就出来了：比特率、帧率和刷新率。接下来我们简单介绍一下他们的作用： 视频帧： 常见有I帧（关键帧，含完整画面，所以数据量大）、P帧（前向参考帧，参考前面I帧编码的图像信息）、B帧（双向预测帧，参考前面I帧、前面P帧和后面I帧编码的图像信息）；我们网上看视频时常常会遇到拖动进度条出现回退一两秒的情况吧？因为那个位置的当前帧不是I帧，没有完整的画面。 分辨率： 图像的大小或尺寸。 RGB： 任何彩色图像可由红绿蓝组成。RGB每一个通道占8位，1个字节内存。每个像素包含一个RGB，占3个字节（如果加上透明度RGBA则占32位，总共4个字节）。如：1920 x 1080内存大小=1920 x 1080 x 3=5.9M。 YUV(YCbCr)： Y：亮度；UV：色度和饱和度；wiki YCbCr 介绍。目前大多数都是使用yuv格式来表示视频帧的裸流数据。具体详情请往下阅读。 比特率(码率)： 单位时间内播放媒体（包括视频和音频）的比特数量（bit的数量）。文件大小计算公式： 文件大小（b）= 码率（b/s）x 时间（s） 帧率(帧数)： 画面每秒传输帧数，单位：fps（frame per second）或者 “赫兹”（Hz）。对于人眼感官常用范围在15~75fps之间。 刷新率： 屏幕在每秒刷新（画面）的次数。单位：赫兹（Hz）。 YUV基本介绍 人类视觉系统（HVS）对亮度比彩色更敏感，所以把Y和UV单独抽出来，每一个像素点都有一个Y，4个Y和一组UV（UV数量不定）共同绘制4个像素点，而Y和UV的比例不一样就分了多种 取样格式。 YUV与RGB的相互转化 RGB转YUV： Y = 0.299R + 0.587G + 0.114B U = 0.564(B - Y) V = 0.713(R - Y) YUV转RGB： R = Y + 1.402V B = Y + 1.772U G = Y - 0.344U - 0.714V YUV取样格式 常见的取样格式有以下3种 4：4：4 每4个素位置都有4个YUV，内存计算：1920 x 1080 = 1920 x 1080 x 3=5.9M； 4：2：2 每4个Y像素具有2个U和2个V；内存计算：1920 x 1080 = 1920 x 1080 x (1 + 2/4 + 2/4)=3.9M； 4：2：0 每4个Y像素具有1个U和1个V，使用在视频领域中应用最广泛。内存计算：1920 x 1080 = 1920 x 1080 x (1 + 1/4 + 1/4)=2.8M； YUV数据排列格式 在这里介绍两种格式，一种是Android平台特有NV21（又称YUV420SP），另一种则是其他大部分平台同样的I420（又称YUV420P），这两个取样格式都是4:2:0，所以说他们两种的数据完全一样，只是放到内存里面的顺序变了。（我们要实现把从Android采样NV21数据转成I420然后推送到服务器。） NV21： ①先把Y数据全部排序完；②UV数据交替排序完； I420： ①先把Y数据全部排序完；②U数据排序完；③V数据排序完； YUV初步实战 手写分离YUV分量以及对其进行播放 请前往 视音频数据处理入门：RGB、YUV像素数据处理 进行学习。对“前人种树，后人乘凉”感触颇深，只是太可惜了！ YUV数据源的采集（Android端） //1.相机权限 //2.获取相机，有后置摄像头：Camera.CameraInfo.CAMERA_FACING_BACK和前置摄像头：Camera.CameraInfo.CAMERA_FACING_FRONT Camera camera = Camera.open(cameraId); //3、Parameters这里封装着当前摄像头所能提供的参数（真实宽高等） Camera.Parameters parameters = camera.getParameters(); //根据parameters.getSupportedPreviewSizes()提供的宽高尺寸挑选一个设置进去 parameters.setPreviewSize(width, height); //设置预览数据为nv21（注意：仅仅是预览的数据，通过onPreviewFrame回调的仍没有发生变化） parameters.setPreviewFormat(ImageFormat.NV21); //设置预览角度，通过WindowManager.getDefaultDisplay().getRotation()参数查看。（因为android手机厂商安装摄像头传感器方向不统一，所以数据可能是旋转过的，所以要回正） camera.setDisplayOrientation(degrees); //设置修改过的数据，使得生效 camera.setParameters(parameters); //4、设置数据监听，我们会在onPreviewFrame(byte[] data, Camera camera)处理回调的数据，这里的数据就是每一帧原始数据流。我们会先把数据按照角度回正（注意回正后的宽高可能是调换的），然后转成I420就行编码发送。 camera.setPreviewCallbackWithBuffer(this); //5、启动预览画面 camera.setPreviewDisplay(holder); camera.startPreview(); NV21数据旋转 比如NV21数据以及顺时针旋转90度后的对比： 实现顺时针和逆时针旋转90度的代码： /** *yuv_n21_rotation(\"assets/yuv_nv21_800x480_back.yuv\",800,480,90,\"output/out_nv21_480x800_back.yuv\"); * 从android摄像机获取到的nv21格式数据，进行旋转 */ int yuv_n21_rotation(const char *url_in, int width, int height, int rotation, const char *url_out) &#123; FILE *pIn = fopen(url_in, \"rb+\"); FILE *pOut = fopen(url_out, \"wb+\"); int yuvSize = width * height * 3 / 2; unsigned char *simple = (unsigned char *) malloc(yuvSize); unsigned char *simpleOut = (unsigned char *) malloc(yuvSize); fread(simple, 1, yuvSize, pIn); //顺时针旋转90 if (rotation == 90) &#123; //宽高取反，把竖变行 int k = 0; //宽高取反，把竖变行 //y数据 for (int w = 0; w &lt; width; w++) &#123; for (int h = height - 1; h &gt;= 0; h--) &#123; simpleOut[k++] = simple[h * width + w]; &#125; &#125; //uv数据 height*width -&gt; 3/2height*width for (int w = 0; w &lt; width; w+=2) &#123; for (int h = height / 2 - 1; h &gt;= 0; h--) &#123; // *(simpleOut + k) = simple[width * height + h * width + w]; // u simpleOut[k++] = simple[width*height + width * h + w]; // v simpleOut[k++] = simple[width*height + width * h + w + 1]; &#125; &#125; &#125; else if(rotation == -90)&#123; //宽高取反，把竖变行 int k = 0; //宽高取反，把竖变行 //y数据 for (int w = width -1; w &gt;= 0; w--) &#123; for (int h = 0; h &lt; height; h++) &#123; simpleOut[k++] = simple[h * width + w]; &#125; &#125; //uv数据 height*width -&gt; 3/2height*width for (int w = 0; w &lt; width; w+=2) &#123; for (int h = height / 2 - 1; h &gt;= 0; h--) &#123; // *(simpleOut + k) = simple[width * height + h * width + w]; simpleOut[k++] = simple[width*height + width * h + w]; simpleOut[k++] = simple[width*height + width * h + w + 1]; &#125; &#125; &#125; fwrite(simpleOut, 1, yuvSize, pOut); return 0; &#125; NV21数据格式转I420数据格式 //nv21_to_i420(\"assets/yuv_nv21_800x480_back.yuv\",800,480,\"output/out_yuv_i420_800x480_back.yuv\"); int nv21_to_i420(const char *url_in, int width, int height, const char *url_out)&#123; FILE *pIn = fopen(url_in, \"rb+\"); FILE *pOut = fopen(url_out, \"wb+\"); int ySize = width * height; int uvSize = ySize /2; int yuvSize = ySize * 3 / 2; unsigned char *simple = (unsigned char *) malloc(yuvSize); unsigned char *simpleOut = (unsigned char *) malloc(yuvSize); fread(simple,yuvSize,1,pIn); //y memcpy(simpleOut, simple, ySize); for (int i = 0; i &lt; uvSize/2; i++) &#123; //u *(simpleOut + ySize + i) = *(simple + ySize + i * 2); //v *(simpleOut + ySize + i + uvSize/2) = *(simple + ySize + i * 2 + 1); &#125; fwrite(simpleOut,yuvSize,1,pOut); fclose(pIn); fclose(pOut); return 0; &#125; 参考 wiki YCbCr 视音频数据处理入门：RGB、YUV像素数据处理 新一代视频压缩编码标准-H.264_AVC(第二版) （书） 音视频开发进阶指南：基于Android与iOS平台的实践（书） Android 音视频开发_何俊林（书）","categories":[],"tags":[{"name":"直播推流全过程","slug":"直播推流全过程","permalink":"http://qincji.gitee.io/tags/%E7%9B%B4%E6%92%AD%E6%8E%A8%E6%B5%81%E5%85%A8%E8%BF%87%E7%A8%8B/"}]}],"categories":[],"tags":[{"name":"直播推流全过程","slug":"直播推流全过程","permalink":"http://qincji.gitee.io/tags/%E7%9B%B4%E6%92%AD%E6%8E%A8%E6%B5%81%E5%85%A8%E8%BF%87%E7%A8%8B/"},{"name":"其他","slug":"其他","permalink":"http://qincji.gitee.io/tags/%E5%85%B6%E4%BB%96/"}]}